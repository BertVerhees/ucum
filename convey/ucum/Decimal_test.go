package ucum

import (
	"testing"
	"github.com/smartystreets/goconvey/convey"
	"UCUM_Golang/ucum"
	"strconv"
	"github.com/smartystreets/assertions/should"
)



func TestStringAsIntegerDecimal(t *testing.T){
	var integerTable = []int{
		0, 1, 2, 64, ucum.MAX_INT, -1, -2, -64, ucum.MIN_INT,
	}
	convey.Convey("TestStringAsIntegerDecimal", t, func() {
		for _, integer := range integerTable {
			d, err := ucum.NewDecimal(strconv.Itoa(integer))
			convey.So(err, should.BeNil)
			i, err := d.AsInteger()
			convey.So(err, should.BeNil)
			convey.So(i, should.Equal, integer)
		}
	})
}

func TestDecimalAsScientific(t *testing.T) {
	var DecimalScientificMap = map[string]string{
		"1": "1e0",
		"0":  "0e0",
		"-0":  "0e0",
		"10":  "1.0e1",
		"99":  "9.9e1",
		"-1": "-1e0",
		"-10": "-1.0e1",
		"-99": "-9.9e1",
		"1.1": "1.1e0",
		"-1.1":  "-1.1e0",
		"11.1":  "1.11e1",
		"1.11": "1.11e0",
		"1.111": "1.111e0",
		"0.1": "1e-1",
		"00.1": "1e-1",
		".1": "1e-1",
		"1.0": "1.0e0",
		"1.00": "1.00e0",
		"1.000000000000000000000000000000000000000": "1.000000000000000000000000000000000000000e0",
		"-11.1": "-1.11e1",
		"-1.11": "-1.11e0",
		"-1.111":  "-1.111e0",
		"-0.1":  "-1e-1",
		"-00.1":  "-1e-1",
		"-.1": "-1e-1",
		"-1.0":  "-1.0e0",
		"-1.00": "-1.00e0",
		"-1.000000000000000000000000000000000000000":  "-1.000000000000000000000000000000000000000e0",
		"0.0": "0.0e0",
		"0.0000":  "0.0000e0",
		"0.100": "1.00e-1",
		"100": "1.00e2",
		"0.01": "1e-2",
		"0.001": "1e-3",
		"0.0001": "1e-4",
		"00.0001":  "1e-4",
		"000.0001": "1e-4",
		"-0.01": "-1e-2",
		"10.01":  "1.001e1",
		"0.00001": "1e-5",
		"0.000001": "1e-6",
		"0.0000001": "1e-7",
		"0.000000001": "1e-9",
		"0.00000000001":  "1e-11",
		"0.0000000000001": "1e-13",
		"0.000000000000001": "1e-15",
		"0.00000000000000001":  "1e-17",
		"10.1": "1.01e1",
		"100.1":  "1.001e2",
		"1000.1":  "1.0001e3",
		"10000.1": "1.00001e4",
		"100000.1": "1.000001e5",
		"1000000.1":  "1.0000001e6",
		"10000000.1":  "1.00000001e7",
		"100000000.1":  "1.000000001e8",
		"1000000000.1":  "1.0000000001e9",
		"10000000000.1":  "1.00000000001e10",
		"100000000000.1":  "1.000000000001e11",
		"1000000000000.1": "1.0000000000001e12",
		"10000000000000.1":  "1.00000000000001e13",
		"100000000000000.1":  "1.000000000000001e14",
	}
	convey.Convey("TestDecimalToScientific", t, func() {
		for k,v := range DecimalScientificMap {
			d,err := ucum.NewDecimal(k)
			convey.So(err, should.BeNil)
			s := d.AsScientific()
			convey.So(s, should.Equal, v)
		}
	})
}

func TestScientificAsDecimal(t *testing.T) {
	var ScientificDecimalMap = map[string]string{
		"1e0":"1",
		"0e0":"0",
		"1.0e1":"10",
		"9.9e1":"99",
		"-1e0":"-1",
		"-1.0e1":"-10",
		"-9.9e1":"-99",
		"1.1e0":"1.1",
		"-1.1e0":"-1.1",
		"1.11e1":"11.1",
		"1.11e0":"1.11",
		"1.111e0":"1.111",
		"1e-1":"0.1",
		"1.0e0":"1.0",
		"1.00e0":"1.00",
		"1.000000000000000000000000000000000000000e0":"1.000000000000000000000000000000000000000",
		"-1.11e1":"-11.1",
		"-1.11e0":"-1.11",
		"-1.111e0":"-1.111",
		"-1e-1":"-0.1",
		"-1.0e0":"-1.0",
		"-1.00e0":"-1.00",
		"-1.000000000000000000000000000000000000000e0":"-1.000000000000000000000000000000000000000",
		"0.0e0":"0.0",
		"0.0000e0":"0.0000",
		"1.00e-1":"0.100",
		"1.00e2":"100",
		"1e-2":"0.01",
		"1e-3":"0.001",
		"1e-4":"0.0001",
		"-1e-2":"-0.01",
		"1.001e1":"10.01",
		"1e-5":"0.00001",
		"1e-6": "0.000001",
		"1e-7":"0.0000001",
		"1e-9":"0.000000001",
		"1e-11":"0.00000000001",
		"1e-13":"0.0000000000001",
		"1e-15": "0.000000000000001",
		"1e-17":"0.00000000000000001",
		"1.01e1": "10.1",
		"1.001e2": "100.1",
		"1.0001e3":"1000.1",
		"1.00001e4":"10000.1",
		"1.000001e5":"100000.1",
		"1.0000001e6":"1000000.1",
		"1.00000001e7": "10000000.1",
		"1.000000001e8":"100000000.1",
		"1.0000000001e9":"1000000000.1",
		"1.00000000001e10":"10000000000.1",
		"1.000000000001e11":"100000000000.1",
		"1.0000000000001e12":"1000000000000.1",
		"1.00000000000001e13":"10000000000000.1",
		"1.000000000000001e14": "100000000000000.1",
	}

		convey.Convey("TestDecimalToString", t, func() {
			for k, v := range ScientificDecimalMap {
				d, err := ucum.NewDecimal(k)
				convey.So(err, should.BeNil)
				s := d.AsDecimal()
				convey.So(s, should.Equal, v)
			}
		})
}

func TestDecimalToString(t *testing.T) {
	var DecimalToStringMap = map[string]string{
		"1": "1",
		"0": "0",
		"-0": "0",
		"10": "10",
		"99": "99",
		"-1": "-1",
		"-10": "-10",
		"-99": "-99",
		"1.1": "1.1",
		"-1.1": "-1.1",
		"11.1": "11.1",
		"1.11": "1.11",
		"1.111": "1.111",
		"0.1": "0.1",
		"00.1": "0.1",
		".1": "0.1",
		"1.0": "1.0",
		"1.00": "1.00",
		"1.000000000000000000000000000000000000000": "1.000000000000000000000000000000000000000",
		"-11.1": "-11.1",
		"-1.11": "-1.11",
		"-1.111": "-1.111",
		"-0.1": "-0.1",
		"-00.1": "-0.1",
		"-.1": "-0.1",
		"-1.0": "-1.0",
		"-1.00": "-1.00",
		"-1.000000000000000000000000000000000000000": "-1.000000000000000000000000000000000000000",
		"0.0": "0.0",
		"0.0000": "0.0000",
		"0.100": "0.100",
		"100": "100",
		"0.01": "0.01",
		"0.001": "0.001",
		"0.0001": "0.0001",
		"00.0001": "0.0001",
		"000.0001": "0.0001",
		"-0.01": "-0.01",
		"10.01": "10.01",
		"0.00001": "0.00001",
		"0.000001": "0.000001",
		"0.0000001": "0.0000001",
		"0.000000001": "0.000000001",
		"0.00000000001": "0.00000000001",
		"0.0000000000001": "0.0000000000001",
		"0.000000000000001": "0.000000000000001",
		"0.00000000000000001": "0.00000000000000001",
		"10.1": "10.1",
		"100.1": "100.1",
		"1000.1": "1000.1",
		"10000.1": "10000.1",
		"100000.1": "100000.1",
		"1000000.1": "1000000.1",
		"10000000.1": "10000000.1",
		"100000000.1": "100000000.1",
		"1000000000.1": "1000000000.1",
		"10000000000.1": "10000000000.1",
		"100000000000.1": "100000000000.1",
		"1000000000000.1": "1000000000000.1",
		"10000000000000.1": "10000000000000.1",
		"100000000000000.1": "100000000000000.1",
	}
	convey.Convey("TestDecimalToString", t, func() {
		d, err := ucum.NewDecimal(strconv.Itoa(ucum.MIN_INT))
		convey.So(err, should.BeNil)
		s := d.String()
		convey.So(s, should.Equal, strconv.Itoa(ucum.MIN_INT))
		d, err = ucum.NewDecimal(strconv.Itoa(ucum.MAX_INT))
		convey.So(err, should.BeNil)
		s = d.String()
		convey.So(s, should.Equal, strconv.Itoa(ucum.MAX_INT))
		for k, v := range DecimalToStringMap {
			d, err = ucum.NewDecimal(k)
			convey.So(err, should.BeNil)
			s = d.String()
			convey.So(s, should.Equal, v)
		}
	})
}

func TestTruncate(t *testing.T) {
	var TruncateMap = map[string]string{
		"1": "1",
		"1.01": "1",
		"-1.01": "-1",
		"0.01": "0",
		"-0.01": "0",
		"0.1": "0",
		"0.0001": "0",
		"100.000000000000000000000000000000000000000001": "100",
	}
	convey.Convey("TestTruncate", t, func() {
		for k, v := range TruncateMap {
			d, err := ucum.NewDecimal(k)
			convey.So(err, should.BeNil)
			s := d.Trunc().String()
			convey.So(s, should.Equal, v)
		}
	})
}

func TestCompare(t *testing.T){
	type compare struct{
		compare1, compare2 string
		outcome int
	}
	var list = []compare{
		{"1", "1",0},
		{"0", "0",0},
		{"0", "1",-1},
		{"1", "0",1},
		{"10","10",0},
		{"100","100",0},
		{"0.1","0.1",0},
		{"0.01","0.01",0},
		{"0.01","0.0100",0},
		{"1","1.00000000",0},
		{"1.111111","1.111111",0},
		{"1.111111","1.1111111",-1},
		{"1.1111111","1.111111",1},
	}
	convey.Convey("TestCompare", t, func() {
		for _,s := range list {
			d1,_ := ucum.NewDecimal(s.compare1)
			d2,_ := ucum.NewDecimal(s.compare2)
			convey.So(d1.ComparesTo(d2),should.Equal,s.outcome)
		}
	})
}

func TestAddition(t *testing.T){
	type add struct{
		s1, s2, result string
	}
	var list = []add{
		{"1", "1", "2"},
		{"0", "1", "1"},
		{"0", "0", "0"},
		{"5", "5", "10"},
		{"10", "1", "11"},
		{"11", "12", "23"},
		{"15", "16", "31"},
		{"150", "160", "310"},
		{"153", "168", "321"},
		{"15300000000000000000000000000000000001", "1680", "15300000000000000000000000000000001681"},
		{"1", ".1", "1.1"},
		{"1", ".001", "1.001"},
		{".1", ".1", "0.2"},
		{".1", ".01", "0.11"},
		{"5", "6", "11"},
		{"5", "-6", "-1"},
		{"-5", "6", "1"},
		{"-5", "-6", "-11"},
		{"2", "0.001", "2.001"},
		{"2.0", "0.001", "2.001"},
	}
	convey.Convey("TestAddition", t, func() {
		for _,s := range list {
			d1,_ := ucum.NewDecimal(s.s1)
			d2,_ := ucum.NewDecimal(s.s2)
			result := d1.Add(d2).String()
			convey.So(result ,should.Equal, s.result)
		}
	})
}

func TestSubtract(t *testing.T){
	type subtract struct{
		s1, s2, result string
	}
	var list = []subtract{
		{"2", "1", "1"},
		{"2", "0", "2"},
		{"0", "0", "0"},
		{"0", "2", "-2"},
		{"2", "2", "0"},
		{"1", "2", "-1"},
		{"20", "1", "19"},
		{"2", ".1", "1.9"},
		{"2", ".000001", "1.999999"},
		{"2", "2.000001", "-0.000001"},
		{"3.5", "35.5", "-32.0"},
		{"5", "6", "-1"},
		{"6", "5", "1"},
		{"5", "-6", "11"},
		{"6", "-5", "11"},
		{"-5", "6", "-11"},
		{"-6", "5", "-11"},
		{"-5", "-6", "1"},
		{"-6", "-5", "-1"},
	}
	convey.Convey("TestSubtract", t, func() {
		for _,s := range list {
			d1,_ := ucum.NewDecimal(s.s1)
			d2,_ := ucum.NewDecimal(s.s2)
			result := d1.Subtract(d2).String()
			convey.So(result ,should.Equal, s.result)
		}
	})
}

func TestMultiply(t *testing.T){
	type multiply struct{
		s1, s2, result string
	}
	var list = []multiply{
		{"2", "2", "4"},
		{"2", "0.5", "1"},
		{"0", "0", "0"},
		{"0", "1", "0"},
		{"4", "4", "16"},
		{"20", "20", "400"},
		{"200", "20", "4000"},
		{"400", "400", "160000"},
		{"2.0", "2.0", "4.0"},
		{"2.00", "2.0", "4.0"},
		{"2.0", "0.2", "0.4"},
		{"2.0", "0.20", "0.40"},
		{"13", "13", "169"},
		{"12", "89", "1068"},
		{"1234", "6789", "8377626"},
		{"10000", "0.0001", "1"},
		{"10000", "0.00010", "1.0"},
		{"10000", "0.000100", "1.00"},
		{"10000", "0.0001000", "1.000"},
		{"10000", "0.00010000", "1.0000"},
		{"10000", "0.000100000", "1.00000"},
		{"10000.0", "0.000100000", "1.00000"},
		{"10000.0", "0.0001000000", "1.00000"},
		{"10000.0", "0.00010000000", "1.00000"},
		{"2", "-2", "-4"},
		{"-2", "2", "-4"},
		{"-2", "-2", "4"},
		{"35328734682734", "2349834295876423", "83016672387407213199375780482"},
		{"35328734682734000000000", "2349834295876423000000000", "83016672387407213199375780482000000000000000000"},
		{"3532873468.2734", "23498342958.76423", "83016672387407213199.375780482"},
	}
	convey.Convey("TestMultiply", t, func() {
		for _,s := range list {
			d1,_ := ucum.NewDecimal(s.s1)
			d2,_ := ucum.NewDecimal(s.s2)
			result := d1.Multiply(d2).String()
			convey.So(result ,should.Equal, s.result)
		}
	})
}

func TestIntegerDivide(t *testing.T){
	type divide struct{
		s1, s2, result string
	}
	var list = []divide{
		{"500", "4", "125"},
		{"1260257", "37", "34061"},
		{"127", "4", "31.75"},
		{"10", "10", "1"},
		{"1", "1", "1"},
		{"10", "3", "3.3"},
		{"10.0", "3", "3.33"},
		{"10.00", "3", "3.333"},
		{"10.00", "3.0", "3.3"},
		{"100", "1", "100"},
		{"1000", "10", "100"},
		{"100001", "10", "10000.1"},
		{"100", "10", "10"},
		{"1", "10", "0.1"},
		{"1", "15", "0.067"},
		{"1.0", "15", "0.067"},
		{"1.00", "15.0", "0.0667"},
		{"1", "0.1", "10"},
		{"1", "0.10", "10"},
		{"1", "0.010", "100"},
		{"1", "1.5", "0.67"},
		{"1.0", "1.5", "0.67"},
		{"10", "1.5", "6.7"},
		{"-1", "1", "-1"},
		{"1", "-1", "-1"},
		{"-1", "-1", "1"},
		{"2", "2", "1"},
		{"20", "2", "10"},
		{"22", "2", "11"},
		{"83016672387407213199375780482", "2349834295876423", "35328734682734"},
		{"83016672387407213199375780482000000000000000000", "2349834295876423000000000", "35328734682734000000000"},
		{"83016672387407213199.375780482", "23498342958.76423", "3532873468.2734"},
	}
	convey.Convey("TestIntegerDivide", t, func() {
		for _,s := range list {
			d1,_ := ucum.NewDecimal(s.s1)
			d2,_ := ucum.NewDecimal(s.s2)
			result := d1.Divide(d2).String()
			convey.So(result ,should.Equal, s.result)
		}
	})
}